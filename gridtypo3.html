<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>gridtypo1 - OpenCV Corner Detection</title>
  <style>
    :root {
      color-scheme: light;
    }
    body {
      margin: 0;
      font-family: "IBM Plex Sans", system-ui, sans-serif;
      background: #f6f4f0;
      color: #1b1b1b;
    }
    .wrap {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 16px;
    }
    .stage {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    canvas {
      max-width: 100%;
      height: auto;
      display: block;
      border-radius: 8px;
      background: #101010;
    }
    .status {
      font-size: 14px;
      opacity: 0.8;
    }
    @media (min-width: 960px) {
      .wrap {
        grid-template-columns: 1.2fr 0.8fr;
        align-items: start;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <div class="row">
        <div class="status" id="status">Loading...</div>
      </div>
      <canvas id="output"></canvas>
    </div>
    <div class="stage">
      <div id="gui"></div>
    </div>
    <div class="stage">
      <pre class="log" id="log"></pre>
    </div>
  </div>

  <script>
    (() => {
      const logEl = document.getElementById("log");
      const statusEl = document.getElementById("status");
      const log = (message) => {
        if (!logEl) return;
        const time = new Date().toISOString().slice(11, 19);
        logEl.textContent += `[${time}] ${message}\n`;
      };
      window.__log = log;
      window.addEventListener("error", (event) => {
        log(`Error: ${event.message}`);
      });
      window.addEventListener("unhandledrejection", (event) => {
        log(`Unhandled: ${event.reason}`);
      });
      if (statusEl) {
        log(`Status: ${statusEl.textContent}`);
      }
    })();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/typescript@5.4.5/lib/typescript.js"></script>

  <script id="ts-app" type="text/typescript">
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm";

    type Mode = "Shi-Tomasi" | "Harris";

    type AppParams = {
      imagePath: string;
      imageFile: string;
      mode: Mode;
      maxCorners: number;
      qualityLevel: number;
      minDistance: number;
      blockSize: number;
      k: number;
      pointRadius: number;
      pointColor: string;
      showPoints: boolean;
      showSource: boolean;
      showGrid: boolean;
      gridColor: string;
      gridThickness: number;
      gridAlpha: number;
      gridMinSpacing: number;
      gridMinPoints: number;
      gridFillMissing: boolean;
      gridTargetSpacing: number;
      gridMode: "Boundary" | "Corners";
      projSmooth: number;
      projK: number;
      projMinDistance: number;
      showContours: boolean;
      contourColor: string;
      contourThickness: number;
      showHierarchy: boolean;
      hierarchyColor: string;
      hierarchyFontScale: number;
      contourMinAreaPercent: number;
      contourSmooth: boolean;
      contourSmoothEpsilonPx: number;
    };

    declare const cv: typeof import("opencv.js");

    const statusEl = document.getElementById("status") as HTMLDivElement;
    const canvas = document.getElementById("output") as HTMLCanvasElement;
    const guiHost = document.getElementById("gui") as HTMLDivElement;
    const log = (window as unknown as { __log?: (message: string) => void }).__log;
    const OPENCV_BASE = "lib/opencv/";
    const OPENCV_SCRIPT = `${OPENCV_BASE}opencv.js`;
    const OPENCV_WASM_CANDIDATES = ["opencv.wasm"];
    const OPENCV_EMBEDDED_WASM = true;

    const params: AppParams = {
      imagePath: "images/z1.jpg",
      imageFile: "z1.jpg",
      mode: "Shi-Tomasi",
      maxCorners: 150,
      qualityLevel: 0.05,
      minDistance: 10,
      blockSize: 2,
      k: 0.02,
      pointRadius: 5,
      pointColor: "#ff0000",
      showPoints: true,
      showSource: true,
      showGrid: true,
      gridColor: "#44ff00",
      gridThickness: 2,
      gridAlpha: 1,
      gridMinSpacing: 10,
      gridMinPoints: 2,
      gridFillMissing: true,
      gridTargetSpacing: 0,
      gridMode: "Boundary",
      projSmooth: 5,
      projK: 1,
      projMinDistance: 6,
      showContours: true,
      contourColor: "#3366ff",
      contourThickness: 2,
      showHierarchy: true,
      hierarchyColor: "#6670ff",
      hierarchyFontScale: 1,
      contourMinAreaPercent: 1,
      contourSmooth: true,
      contourSmoothEpsilonPx: 1,
    };

    const STORAGE_KEY = "gridtypo1-lilgui";

    let sourceImg: HTMLImageElement | null = null;
    let isCvReady = false;
    let cvRef: typeof cv | null = null;
    let imageOptions = ["z1.jpg", "P1.jpg", "S1.jpg", "A1.jpg", "nasa.png"];
    let imageFileController: GUIController<string> | null = null;

    function setStatus(text: string) {
      statusEl.textContent = text;
      if (log) {
        log(`Status: ${text}`);
      }
    }

    async function loadImage(url: string): Promise<HTMLImageElement> {
      const normalizedUrl = normalizePath(url);
      setStatus(`Loading image: ${normalizedUrl}`);
      if (log) {
        log("image load start");
      }

      const controller = new AbortController();
      const timeoutId = window.setTimeout(() => controller.abort(), 8000);
      let blob: Blob;
      try {
        const response = await fetch(normalizedUrl, {
          cache: "no-cache",
          mode: "cors",
          signal: controller.signal,
        });
        if (!response.ok) {
          throw new Error(`Image fetch failed: ${response.status} ${response.statusText}`);
        }
        blob = await response.blob();
      } catch (err) {
        if (log) {
          log(`image fetch error: ${err}`);
        }
        throw err instanceof Error ? err : new Error("Image fetch failed");
      } finally {
        window.clearTimeout(timeoutId);
      }

      if (log) {
        log(`image fetched. size=${Math.round(blob.size / 1024)}KB`);
      }

      return new Promise((resolve, reject) => {
        const img = new Image();
        const objectUrl = URL.createObjectURL(blob);
        const decodeTimeout = window.setTimeout(() => {
          if (log) {
            log("image decode timeout");
          }
          URL.revokeObjectURL(objectUrl);
          reject(new Error(`Image decode timeout: ${normalizedUrl}`));
        }, 8000);
        img.addEventListener("load", () => {
          window.clearTimeout(decodeTimeout);
          URL.revokeObjectURL(objectUrl);
          if (log) {
            log(`image loaded. size=${img.naturalWidth}x${img.naturalHeight}`);
          }
          resolve(img);
        });
        img.addEventListener("error", () => {
          window.clearTimeout(decodeTimeout);
          URL.revokeObjectURL(objectUrl);
          if (log) {
            log("image error event");
          }
          reject(new Error(`Failed to load image: ${normalizedUrl}`));
        });
        img.src = objectUrl;
      });
    }

    function ensureCanvasSize(width: number, height: number) {
      canvas.width = width;
      canvas.height = height;
    }

    function detectAndDraw() {
      if (!isCvReady || !sourceImg || !cvRef) {
        return;
      }

      const maxCorners = Math.max(1, Math.floor(params.maxCorners));
      const blockSize = Math.max(2, Math.floor(params.blockSize));
      const pointRadius = Math.max(1, Math.floor(params.pointRadius));
      const useHarrisDetector = params.mode === "Harris";

      ensureCanvasSize(sourceImg.naturalWidth, sourceImg.naturalHeight);

      const src = cvRef.imread(sourceImg);
      const gray = new cvRef.Mat();
      cvRef.cvtColor(src, gray, cvRef.COLOR_RGBA2GRAY, 0);

      const corners = new cvRef.Mat();
      const mask = new cvRef.Mat();
      cvRef.goodFeaturesToTrack(
        gray,
        corners,
        maxCorners,
        params.qualityLevel,
        params.minDistance,
        mask,
        blockSize,
        useHarrisDetector,
        params.k
      );

      const output = new cvRef.Mat();
      if (params.showSource) {
        src.copyTo(output);
      } else {
        cvRef.cvtColor(gray, output, cvRef.COLOR_GRAY2RGBA, 0);
      }

      const edges = new cvRef.Mat();
      cvRef.Canny(gray, edges, 60, 120);
      const contours = new cvRef.MatVector();
      const hierarchy = new cvRef.Mat();
      cvRef.findContours(edges, contours, hierarchy, cvRef.RETR_TREE, cvRef.CHAIN_APPROX_SIMPLE);

      const minArea =
        (params.contourMinAreaPercent / 100) *
        (sourceImg.naturalWidth * sourceImg.naturalHeight);
      if (params.showContours) {
        const contourColor = hexToScalar(params.contourColor, 1);
        for (let i = 0; i < contours.size(); i += 1) {
          const contour = contours.get(i);
          const area = Math.abs(cvRef.contourArea(contour));
          contour.delete();
          if (area < minArea) {
            continue;
          }
          if (params.contourSmooth) {
            const raw = contours.get(i);
            const approx = new cvRef.Mat();
            cvRef.approxPolyDP(raw, approx, params.contourSmoothEpsilonPx, true);
            const vec = new cvRef.MatVector();
            vec.push_back(approx);
            cvRef.drawContours(output, vec, 0, contourColor, params.contourThickness);
            vec.delete();
            raw.delete();
            approx.delete();
          } else {
            cvRef.drawContours(output, contours, i, contourColor, params.contourThickness);
          }
        }
      }

      if (params.showHierarchy && hierarchy.data32S) {
        const hierarchyColor = hexToScalar(params.hierarchyColor, 1);
        const bestByDepth = new Map<
          number,
          { area: number; x: number; y: number; n: cv.Vec2; index: number; center: cv.Vec2 }
        >();
        const depthTargets: {
          depth: number;
          x: number;
          y: number;
          n: cv.Vec2;
          index: number;
          center: cv.Vec2;
        }[] = [];
        for (let i = 0; i < contours.size(); i += 1) {
          const contour = contours.get(i);
          const area = Math.abs(cvRef.contourArea(contour));
          if (area < minArea) {
            contour.delete();
            continue;
          }
          const depth = getHierarchyDepth(i, hierarchy.data32S);
          const topRight = getContourTopRightWithNormal(contour);
          const x = topRight.x;
          const y = topRight.y;
          const n = topRight.n;
          const c = getContourCentroid(contour);
          contour.delete();
          const current = bestByDepth.get(depth);
          if (!current || area > current.area) {
            bestByDepth.set(depth, { area, x, y, n, index: i, center: c });
          }
        }
        for (const [depth, data] of bestByDepth.entries()) {
          if (depth !== 0 && depth !== 1) {
            continue;
          }
          let x = data.x;
          let y = data.y;
          depthTargets.push({ depth, x, y, n: data.n, index: data.index, center: data.center });
        }
        depthTargets.sort((a, b) => a.depth - b.depth);
        const placed: { x: number; y: number }[] = [];
        const jitter = 10;
        const offset = Math.max(6, params.contourThickness * 3);
        for (const target of depthTargets) {
          let x = target.x;
          let y = target.y;
          if (x < 0) {
            x = 0;
          }
          if (y < 0) {
            y = 0;
          }
          if (x > output.cols - 1) {
            x = output.cols - 1;
          }
          if (y > output.rows - 1) {
            y = output.rows - 1;
          }
          for (const prev of placed) {
            const dx = x - prev.x;
            const dy = y - prev.y;
            if (dx * dx + dy * dy < jitter * jitter) {
              x = Math.min(output.cols - 1, x + jitter);
              y = Math.min(output.rows - 1, y + jitter);
            }
          }
          const contourForTest = contours.get(target.index);
          const vx = target.center[0] - x;
          const vy = target.center[1] - y;
          const vlen = Math.hypot(vx, vy);
          let nx = 0;
          let ny = 0;
          if (vlen > 1e-3) {
            nx = vx / vlen;
            ny = vy / vlen;
          } else {
            nx = target.n[0];
            ny = target.n[1];
          }
          const testInX = x + nx * offset;
          const testInY = y + ny * offset;
          const testOutX = x - nx * offset;
          const testOutY = y - ny * offset;
          const insideIn = cvRef.pointPolygonTest(
            contourForTest,
            new cvRef.Point(testInX, testInY),
            false
          );
          const insideOut = cvRef.pointPolygonTest(
            contourForTest,
            new cvRef.Point(testOutX, testOutY),
            false
          );
          if (insideIn <= 0 && insideOut > 0) {
            nx = -nx;
            ny = -ny;
          }
          let innerX = x + nx * offset * 10;
          let innerY = y + ny * offset * 3;
          let innerInside = cvRef.pointPolygonTest(
            contourForTest,
            new cvRef.Point(innerX, innerY),
            false
          );
          if (innerInside <= 0) {
            for (let step = 2; step <= 6 && innerInside <= 0; step += 1) {
              innerX = x + nx * offset * step;
              innerY = y + ny * offset * step;
              innerInside = cvRef.pointPolygonTest(
                contourForTest,
                new cvRef.Point(innerX, innerY),
                false
              );
            }
          }
          const outerX = x - nx * offset;
          const outerY = y - ny * offset;
          innerX = clamp(innerX, 0, output.cols - 1);
          innerY = clamp(innerY, 0, output.rows - 1);
          const clampedOuterX = clamp(outerX, 0, output.cols - 1);
          const clampedOuterY = clamp(outerY, 0, output.rows - 1);
          if (target.depth === 1) {
            cvRef.putText(
              output,
              "1",
              new cvRef.Point(innerX, innerY),
              cvRef.FONT_HERSHEY_SIMPLEX,
              params.hierarchyFontScale,
              hierarchyColor,
              2
            );
          }
          if (target.depth === 0) {
            cvRef.putText(
              output,
              "0",
              new cvRef.Point(clampedOuterX, clampedOuterY),
              cvRef.FONT_HERSHEY_SIMPLEX,
              params.hierarchyFontScale,
              hierarchyColor,
              2
            );
          }
          placed.push({ x, y });
          contourForTest.delete();
        }
      }

      if (params.showGrid) {
        let gridXs: number[] = [];
        let gridYs: number[] = [];
        if (params.gridMode === "Corners") {
          const cornerXs: number[] = [];
          const cornerYs: number[] = [];
          for (let i = 0; i < corners.rows; i += 1) {
            cornerXs.push(corners.data32F[i * 2]);
            cornerYs.push(corners.data32F[i * 2 + 1]);
          }
          const mergedXs = mergeBySpacing(cornerXs, params.gridMinSpacing);
          const mergedYs = mergeBySpacing(cornerYs, params.gridMinSpacing);
          const tolerance = Math.max(2, params.gridMinSpacing);
          const filteredXs = mergedXs.filter(
            (x) => countPointsNearLine(cornerXs, x, tolerance) >= params.gridMinPoints
          );
          const filteredYs = mergedYs.filter(
            (y) => countPointsNearLine(cornerYs, y, tolerance) >= params.gridMinPoints
          );
          gridXs = params.gridFillMissing
            ? fillMissingLines(filteredXs, params.gridTargetSpacing)
            : filteredXs;
          gridYs = params.gridFillMissing
            ? fillMissingLines(filteredYs, params.gridTargetSpacing)
            : filteredYs;
        } else {
          const projX = projectEdges(edges, true);
          const projY = projectEdges(edges, false);
          const smoothX = smooth1d(projX, params.projSmooth);
          const smoothY = smooth1d(projY, params.projSmooth);
          const peaksX = findPeaksAuto(smoothX, params.projK, params.projMinDistance);
          const peaksY = findPeaksAuto(smoothY, params.projK, params.projMinDistance);
          gridXs = params.gridFillMissing
            ? fillMissingLines(peaksX, params.gridTargetSpacing)
            : peaksX;
          gridYs = params.gridFillMissing
            ? fillMissingLines(peaksY, params.gridTargetSpacing)
            : peaksY;
        }
        const gridColor = hexToScalar(params.gridColor, params.gridAlpha);
        for (const x of gridXs) {
          cvRef.line(
            output,
            new cvRef.Point(x, 0),
            new cvRef.Point(x, output.rows - 1),
            gridColor,
            params.gridThickness
          );
        }
        for (const y of gridYs) {
          cvRef.line(
            output,
            new cvRef.Point(0, y),
            new cvRef.Point(output.cols - 1, y),
            gridColor,
            params.gridThickness
          );
        }
      }

      if (params.showPoints) {
        const pointColor = hexToScalar(params.pointColor, 1);
        for (let i = 0; i < corners.rows; i += 1) {
          const x = corners.data32F[i * 2];
          const y = corners.data32F[i * 2 + 1];
          cvRef.circle(output, new cvRef.Point(x, y), pointRadius, pointColor, -1);
        }
      }

      cvRef.imshow(canvas, output);

      src.delete();
      gray.delete();
      corners.delete();
      mask.delete();
      edges.delete();
      contours.delete();
      hierarchy.delete();
      output.delete();
    }

    function hexToScalar(hex: string, alpha = 1): cv.Scalar {
      const normalized = hex.replace("#", "");
      const r = parseInt(normalized.substring(0, 2), 16) || 0;
      const g = parseInt(normalized.substring(2, 4), 16) || 0;
      const b = parseInt(normalized.substring(4, 6), 16) || 0;
      const a = Math.max(0, Math.min(1, alpha));
      // output is RGBA, so use RGBA order
      return new cvRef!.Scalar(r, g, b, Math.round(a * 255));
    }

    function mergeBySpacing(values: number[], minSpacing: number): number[] {
      if (values.length === 0) {
        return [];
      }
      const sorted = [...values].sort((a, b) => a - b);
      const merged: number[] = [];
      let current = sorted[0];
      let count = 1;
      for (let i = 1; i < sorted.length; i += 1) {
        const value = sorted[i];
        if (Math.abs(value - current) <= minSpacing) {
          current = (current * count + value) / (count + 1);
          count += 1;
        } else {
          merged.push(current);
          current = value;
          count = 1;
        }
      }
      merged.push(current);
      return merged;
    }

    function projectEdges(edgesMat: cv.Mat, sumAlongX: boolean): number[] {
      const rows = edgesMat.rows;
      const cols = edgesMat.cols;
      const data = edgesMat.data;
      if (sumAlongX) {
        const proj = new Array(cols).fill(0);
        for (let y = 0; y < rows; y += 1) {
          const rowOffset = y * cols;
          for (let x = 0; x < cols; x += 1) {
            if (data[rowOffset + x] > 0) {
              proj[x] += 1;
            }
          }
        }
        return normalizeArray(proj);
      }
      const proj = new Array(rows).fill(0);
      for (let y = 0; y < rows; y += 1) {
        const rowOffset = y * cols;
        let sum = 0;
        for (let x = 0; x < cols; x += 1) {
          if (data[rowOffset + x] > 0) {
            sum += 1;
          }
        }
        proj[y] = sum;
      }
      return normalizeArray(proj);
    }

    function normalizeArray(values: number[]): number[] {
      let max = 0;
      for (const v of values) {
        if (v > max) {
          max = v;
        }
      }
      if (max === 0) {
        return values.map(() => 0);
      }
      return values.map((v) => v / max);
    }

    function smooth1d(values: number[], windowSize: number): number[] {
      if (windowSize <= 1) {
        return [...values];
      }
      const half = Math.floor(windowSize / 2);
      const smoothed = new Array(values.length).fill(0);
      for (let i = 0; i < values.length; i += 1) {
        let acc = 0;
        let count = 0;
        for (let k = -half; k <= half; k += 1) {
          const idx = i + k;
          if (idx >= 0 && idx < values.length) {
            acc += values[idx];
            count += 1;
          }
        }
        smoothed[i] = acc / Math.max(1, count);
      }
      return smoothed;
    }

    function findPeaks(values: number[], threshold: number, minDistance: number): number[] {
      const peaks: number[] = [];
      let lastPeak = -Infinity;
      for (let i = 1; i < values.length - 1; i += 1) {
        const v = values[i];
        if (v < threshold) {
          continue;
        }
        if (v >= values[i - 1] && v >= values[i + 1] && i - lastPeak >= minDistance) {
          peaks.push(i);
          lastPeak = i;
        }
      }
      return peaks;
    }

    function findPeaksAuto(values: number[], k: number, minDistance: number): number[] {
      const stats = meanStd(values);
      const threshold = stats.mean + k * stats.std;
      return findPeaks(values, threshold, minDistance);
    }

    function meanStd(values: number[]): { mean: number; std: number } {
      if (values.length === 0) {
        return { mean: 0, std: 0 };
      }
      let sum = 0;
      for (const v of values) {
        sum += v;
      }
      const mean = sum / values.length;
      let varSum = 0;
      for (const v of values) {
        const d = v - mean;
        varSum += d * d;
      }
      const std = Math.sqrt(varSum / values.length);
      return { mean, std };
    }

    function countPointsNearLine(values: number[], line: number, tolerance: number): number {
      let count = 0;
      for (const value of values) {
        if (Math.abs(value - line) <= tolerance) {
          count += 1;
        }
      }
      return count;
    }

    function fillMissingLines(values: number[], targetSpacing: number): number[] {
      if (values.length < 2) {
        return values;
      }
      const sorted = [...values].sort((a, b) => a - b);
      const gaps: number[] = [];
      for (let i = 1; i < sorted.length; i += 1) {
        gaps.push(sorted[i] - sorted[i - 1]);
      }
      const spacing = targetSpacing > 0 ? targetSpacing : median(gaps);
      if (!Number.isFinite(spacing) || spacing <= 0) {
        return sorted;
      }
      const filled: number[] = [sorted[0]];
      for (let i = 1; i < sorted.length; i += 1) {
        const prev = sorted[i - 1];
        const next = sorted[i];
        const gap = next - prev;
        const steps = Math.round(gap / spacing);
        if (steps > 1) {
          const stepSize = gap / steps;
          for (let s = 1; s < steps; s += 1) {
            filled.push(prev + stepSize * s);
          }
        }
        filled.push(next);
      }
      return filled;
    }

    function median(values: number[]): number {
      if (values.length === 0) {
        return 0;
      }
      const sorted = [...values].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      if (sorted.length % 2 === 0) {
        return (sorted[mid - 1] + sorted[mid]) / 2;
      }
      return sorted[mid];
    }

    function getHierarchyDepth(index: number, hierarchyData: Int32Array): number {
      let depth = 0;
      let parent = hierarchyData[index * 4 + 3];
      while (parent !== -1) {
        depth += 1;
        parent = hierarchyData[parent * 4 + 3];
      }
      return depth;
    }

    function getContourTopRightWithNormal(contour: cv.Mat): { x: number; y: number; n: cv.Vec2 } {
      const data = contour.data32S;
      if (!data || data.length < 2) {
        const rect = cvRef!.boundingRect(contour);
        return { x: rect.x + rect.width, y: rect.y, n: [1, -1] };
      }
      let maxX = data[0];
      let minYAtMaxX = data[1];
      let idx = 0;
      const eps = 1;
      for (let i = 0; i < data.length; i += 2) {
        const x = data[i];
        const y = data[i + 1];
        if (x > maxX + eps) {
          maxX = x;
          minYAtMaxX = y;
          idx = i;
        } else if (Math.abs(x - maxX) <= eps && y < minYAtMaxX) {
          minYAtMaxX = y;
          idx = i;
        }
      }
      const prev = (idx - 2 + data.length) % data.length;
      const next = (idx + 2) % data.length;
      const px = data[prev];
      const py = data[prev + 1];
      const nx = data[next];
      const ny = data[next + 1];
      const tx = nx - px;
      const ty = ny - py;
      let n0 = -ty;
      let n1 = tx;
      const len = Math.hypot(n0, n1) || 1;
      n0 /= len;
      n1 /= len;
      return { x: maxX, y: minYAtMaxX, n: [n0, n1] };
    }

    function getContourCentroid(contour: cv.Mat): cv.Vec2 {
      const m = cvRef!.moments(contour);
      if (m.m00 !== 0) {
        return [m.m10 / m.m00, m.m01 / m.m00];
      }
      const rect = cvRef!.boundingRect(contour);
      return [rect.x + rect.width * 0.5, rect.y + rect.height * 0.5];
    }

    function clamp(value: number, min: number, max: number): number {
      return Math.min(max, Math.max(min, value));
    }


    function setupGui() {
      const gui = new GUI({ container: guiHost, title: "OpenCV" });
      const imageFolder = gui.addFolder("Image");
      imageFolder.add(params, "imagePath").name("imagePath").onFinishChange(() => {
        handleImagePathChange();
      });
      imageFileController = imageFolder
        .add(params, "imageFile", imageOptions)
        .name("imageFile")
        .onChange((value: string) => {
          const folder = getFolderPath(params.imagePath);
          params.imagePath = joinPath(folder, value);
          reloadImage();
        });

      const cornersFolder = gui.addFolder("Corners");
      cornersFolder.add(params, "mode", ["Shi-Tomasi", "Harris"]).name("mode").onChange(detectAndDraw);
      cornersFolder.add(params, "maxCorners", 10, 1000, 1).name("maxCorners").onChange(detectAndDraw);
      cornersFolder.add(params, "qualityLevel", 0.001, 0.2, 0.001).name("qualityLevel").onChange(detectAndDraw);
      cornersFolder.add(params, "minDistance", 1, 50, 1).name("minDistance").onChange(detectAndDraw);
      cornersFolder.add(params, "blockSize", 2, 15, 1).name("blockSize").onChange(detectAndDraw);
      cornersFolder.add(params, "k", 0.01, 0.1, 0.005).name("k").onChange(detectAndDraw);
      cornersFolder.add(params, "pointRadius", 1, 10, 1).name("pointRadius").onChange(detectAndDraw);
      cornersFolder.addColor(params, "pointColor").name("pointColor").onChange(detectAndDraw);
      cornersFolder.add(params, "showPoints").name("showPoints").onChange(detectAndDraw);

      const gridFolder = gui.addFolder("Grid");
      gridFolder.add(params, "showGrid").name("showGrid").onChange(detectAndDraw);
      gridFolder.add(params, "gridMode", ["Boundary", "Corners"]).name("gridMode").onChange(detectAndDraw);
      gridFolder.addColor(params, "gridColor").name("gridColor").onChange(detectAndDraw);
      gridFolder.add(params, "gridThickness", 1, 6, 1).name("gridThickness").onChange(detectAndDraw);
      gridFolder.add(params, "gridAlpha", 0.1, 1, 0.05).name("gridAlpha").onChange(detectAndDraw);
      gridFolder.add(params, "gridMinSpacing", 1, 30, 1).name("gridMinSpacing").onChange(detectAndDraw);
      gridFolder.add(params, "gridMinPoints", 1, 5, 1).name("gridMinPoints").onChange(detectAndDraw);
      gridFolder.add(params, "gridFillMissing").name("gridFillMissing").onChange(detectAndDraw);
      gridFolder.add(params, "gridTargetSpacing", 0, 100, 1).name("gridTargetSpacing").onChange(detectAndDraw);

      const projFolder = gui.addFolder("Projection");
      projFolder.add(params, "projSmooth", 1, 21, 2).name("projSmooth").onChange(detectAndDraw);
      projFolder.add(params, "projK", 0.2, 2.5, 0.1).name("projK").onChange(detectAndDraw);
      projFolder.add(params, "projMinDistance", 1, 30, 1).name("projMinDistance").onChange(detectAndDraw);

      const contourFolder = gui.addFolder("Contours");
      contourFolder.add(params, "showContours").name("showContours").onChange(detectAndDraw);
      contourFolder.addColor(params, "contourColor").name("contourColor").onChange(detectAndDraw);
      contourFolder.add(params, "contourThickness", 1, 6, 1).name("contourThickness").onChange(detectAndDraw);
      contourFolder.add(params, "contourSmooth").name("contourSmooth").onChange(detectAndDraw);
      contourFolder.add(params, "contourSmoothEpsilonPx", 0.5, 10, 0.5).name("contourSmoothEpsPx").onChange(detectAndDraw);
      contourFolder.add(params, "contourMinAreaPercent", 0, 5, 0.05).name("minArea%").onChange(detectAndDraw);

      const hierarchyFolder = gui.addFolder("Hierarchy");
      hierarchyFolder.add(params, "showHierarchy").name("showHierarchy").onChange(detectAndDraw);
      hierarchyFolder.addColor(params, "hierarchyColor").name("hierarchyColor").onChange(detectAndDraw);
      hierarchyFolder.add(params, "hierarchyFontScale", 0.3, 2, 0.1).name("hierarchyFontScale").onChange(detectAndDraw);

      const viewFolder = gui.addFolder("View");
      viewFolder.add(params, "showSource").name("showSource").onChange(detectAndDraw);

      const copyText = async (text: string) => {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(text);
          return;
        }
        const textarea = document.createElement("textarea");
        textarea.value = text;
        textarea.style.position = "fixed";
        textarea.style.opacity = "0";
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
      };

      const io = {
        save: () => {
          const data = gui.save();
          localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        },
        load: () => {
          const saved = localStorage.getItem(STORAGE_KEY);
          if (!saved) {
            return;
          }
          gui.load(JSON.parse(saved));
          detectAndDraw();
        },
        reset: () => {
          gui.reset();
          detectAndDraw();
        },
        copy: async () => {
          const data = gui.save();
          await copyText(JSON.stringify(data, null, 2));
          setStatus("Preset copied to clipboard");
        },
      };

      gui.add(io, "save").name("save preset");
      gui.add(io, "load").name("load preset");
      gui.add(io, "reset").name("reset");
      gui.add(io, "copy").name("copy preset");
    }

    function loadOpenCvScript(): Promise<void> {
      return new Promise((resolve, reject) => {
        const existing = document.getElementById("opencv-script");
        if (existing) {
          resolve();
          return;
        }
        const script = document.createElement("script");
        script.id = "opencv-script";
        script.async = true;
        script.crossOrigin = "anonymous";
        script.src = OPENCV_SCRIPT;
        script.onload = () => {
          if (log) {
            log("opencv.js loaded");
          }
          resolve();
        };
        script.onerror = () => {
          if (log) {
            log("opencv.js failed to load");
          }
          reject(new Error("opencv.js failed to load"));
        };
        document.head.appendChild(script);
      });
    }

    function waitForCvReady(timeoutMs = 15000): Promise<void> {
      return new Promise((resolve, reject) => {
        const start = performance.now();
        const timer = window.setInterval(() => {
          if (isCvReady) {
            window.clearInterval(timer);
            resolve();
            return;
          }
          const candidate = (window as unknown as { cv?: typeof cv }).cv;
          if (candidate && (candidate as typeof cv).Mat) {
            cvRef = candidate as typeof cv;
            isCvReady = true;
            if (log) {
              log("cv detected by polling");
            }
            window.clearInterval(timer);
            resolve();
            return;
          }
          if (performance.now() - start > timeoutMs) {
            window.clearInterval(timer);
            reject(new Error("OpenCV init timeout"));
          }
        }, 100);
      });
    }

    function normalizePath(path: string): string {
      return path.replace(/\\/g, "/");
    }

    function getFolderPath(path: string): string {
      const normalized = normalizePath(path);
      if (normalized.endsWith("/")) {
        return normalized;
      }
      const lastSlash = normalized.lastIndexOf("/");
      if (lastSlash === -1) {
        return "";
      }
      return `${normalized.slice(0, lastSlash + 1)}`;
    }

    function basename(path: string): string {
      const normalized = normalizePath(path);
      const parts = normalized.split("/");
      return parts[parts.length - 1] || "";
    }

    function joinPath(base: string, file: string): string {
      const cleanBase = normalizePath(base);
      const cleanFile = basename(file);
      const prefix = cleanBase && !cleanBase.endsWith("/") ? `${cleanBase}/` : cleanBase;
      return `${prefix}${cleanFile}`;
    }

    function looksLikeFolder(path: string): boolean {
      const normalized = normalizePath(path);
      if (normalized.endsWith("/")) {
        return true;
      }
      const lastPart = normalized.split("/").pop() ?? "";
      return !lastPart.includes(".");
    }

    async function discoverImages(folderPath: string): Promise<string[]> {
      const normalizedFolder = normalizePath(folderPath);
      const base = normalizedFolder.endsWith("/") ? normalizedFolder : `${normalizedFolder}/`;
      const response = await fetch(base, { cache: "no-cache" });
      if (!response.ok) {
        throw new Error(`Folder fetch failed: ${response.status} ${response.statusText}`);
      }
      const html = await response.text();
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, "text/html");
      const links = Array.from(doc.querySelectorAll("a"))
        .map((anchor) => anchor.getAttribute("href") || "")
        .filter((href) => href && !href.startsWith("?") && !href.startsWith("#"));
      const files = links
        .map((href) => href.split("?")[0])
        .map((href) => href.split("#")[0])
        .map((href) => href.replace(/^\.?\//, ""))
        .filter((href) => /\.(png|jpg|jpeg|webp|bmp|gif)$/i.test(href))
        .map((href) => basename(href));
      return Array.from(new Set(files)).sort();
    }

    async function handleImagePathChange() {
      const inputPath = normalizePath(params.imagePath.trim());
      if (!inputPath) {
        return;
      }
      if (looksLikeFolder(inputPath)) {
        try {
          setStatus(`Scanning folder: ${inputPath}`);
          const files = await discoverImages(inputPath);
          if (files.length === 0) {
            setStatus("No images found in folder.");
            return;
          }
          imageOptions = files;
          params.imageFile = files[0];
          params.imagePath = joinPath(inputPath, params.imageFile);
          if (imageFileController) {
            imageFileController.options(imageOptions);
            imageFileController.updateDisplay();
          }
          await reloadImage();
        } catch (err) {
          setStatus(err instanceof Error ? err.message : "Folder scan failed");
        }
        return;
      }
      await reloadImage();
    }

    async function reloadImage() {
      sourceImg = null;
      try {
        const img = await loadImage(params.imagePath);
        sourceImg = img;
        setStatus("Image loaded.");
        if (isCvReady) {
          detectAndDraw();
          setStatus("Ready");
        }
      } catch (err) {
        setStatus(err instanceof Error ? err.message : "Failed");
      }
    }

    async function loadOpenCvWasmBinary(): Promise<{ binary: Uint8Array; url: string }> {
      let lastError: Error | null = null;
      for (const file of OPENCV_WASM_CANDIDATES) {
        const wasmUrl = `${OPENCV_BASE}${file}`;
        if (log) {
          log(`fetch wasm: ${wasmUrl}`);
        }
        try {
          const response = await fetch(wasmUrl, { cache: "no-cache", mode: "cors" });
          if (!response.ok) {
            throw new Error(`opencv.wasm fetch failed: ${response.status} ${response.statusText}`);
          }
          const buffer = await response.arrayBuffer();
          return { binary: new Uint8Array(buffer), url: wasmUrl };
        } catch (err) {
          if (log) {
            log(`wasm fetch error: ${err}`);
          }
          lastError = err instanceof Error ? err : new Error("opencv.wasm fetch failed");
        }
      }
      throw lastError ?? new Error("opencv.wasm fetch failed");
    }

    async function bootstrap() {
      setupGui();
      try {
        setStatus("Initializing image...");
        await handleImagePathChange();
        setStatus("Image loaded. Loading OpenCV...");
        const wasmPayload = OPENCV_EMBEDDED_WASM ? null : await loadOpenCvWasmBinary();
        const cvModule =
          (window as unknown as { cv?: Record<string, unknown> }).cv ??
          ({} as Record<string, unknown>);
        (window as unknown as { cv?: Record<string, unknown> }).cv = cvModule;
        if (wasmPayload) {
          cvModule.locateFile = (path: string) => {
            const resolved = path.endsWith(".wasm") ? wasmPayload.url : `${OPENCV_BASE}${path}`;
            if (log) {
              log(`locateFile: ${path} -> ${resolved}`);
            }
            return resolved;
          };
          cvModule.wasmBinary = wasmPayload.binary.buffer;
          cvModule.wasmBinaryFile = wasmPayload.url;
          cvModule.instantiateWasm = (
            imports: WebAssembly.Imports,
            successCallback: (instance: WebAssembly.Instance, module: WebAssembly.Module) => void
          ) => {
            WebAssembly.instantiate(wasmPayload.binary, imports)
              .then((result) => {
                successCallback(result.instance, result.module);
              })
              .catch((err) => {
                if (log) {
                  log(`instantiateWasm error: ${err}`);
                }
                throw err;
              });
            return {};
          };
        }
        cvModule.printErr = (text: string) => {
          if (log) {
            log(`opencv err: ${text}`);
          }
        };
        cvModule.onRuntimeInitialized = () => {
          cvRef = (window as unknown as { cv?: typeof cv }).cv ?? null;
          if (log) {
            log("onRuntimeInitialized");
          }
          if (cvRef) {
            isCvReady = true;
          }
        };
        await loadOpenCvScript();
        await waitForCvReady();
        setStatus("OpenCV ready");
        detectAndDraw();
        setStatus("Ready");
      } catch (err) {
        setStatus(err instanceof Error ? err.message : "Failed");
      }
    }

    bootstrap();
  </script>

  <script>
    (async () => {
      const tsScript = document.getElementById("ts-app");
      if (!tsScript || !window.ts) {
        return;
      }
      const source = tsScript.textContent || "";
      const result = window.ts.transpileModule(source, {
        compilerOptions: {
          target: window.ts.ScriptTarget.ES2020,
          module: window.ts.ModuleKind.ES2020,
          strict: true,
          esModuleInterop: true,
        },
      });
      const blob = new Blob([result.outputText], { type: "text/javascript" });
      const url = URL.createObjectURL(blob);
      await import(url);
      URL.revokeObjectURL(url);
    })();
  </script>
</body>
</html>
