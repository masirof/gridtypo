<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>hand_gridtypo1</title>
  <style>
    :root {
      color-scheme: light;
    }
    body {
      margin: 0;
      font-family: "IBM Plex Sans", system-ui, sans-serif;
      background: #363636;
      color: #e6e6e6;
    }
    .wrap {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0;
      padding: 0;
    }
    .main {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0;
    }
    .stage {
      background: #363636;
      border: 1px solid #5e5e5e;
      border-radius: 0;
      padding: 12px;
      box-shadow: none;
    }
    .wrap > .stage,
    .wrap > .main {
      border: 1px solid #5e5e5e;
    }
    .wrap > .main {
      border-bottom: none;
    }
    .wrap > .stage {
      border-top: 1px solid #5e5e5e;
    }
    .main > .stage {
      border: none;
    }
    .main > .stage + .stage {
      border-left: 1px solid #5e5e5e;
    }
    canvas {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 0;
      background: #363636;
      border: none;
    }
    .status {
      font-size: 14px;
      opacity: 0.8;
      margin-bottom: 8px;
    }
    .lil-gui {
      --background-color: #363636;
      --text-color: #ffffff;
      --title-background-color: #9f9f9f;
      --title-text-color: #000000;
      --number-color: #e8481e;
      --accent-color: #e8481e;
    }
    pre {
      margin: 0;
      font-size: 12px;
      line-height: 1.4;
      white-space: pre-wrap;
    }
    @media (min-width: 960px) {
      .main {
        grid-template-columns: 1.2fr 0.8fr;
        align-items: stretch;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="main">
      <div class="stage">
        <div class="status" id="status">Grid Editor</div>
        <canvas id="grid"></canvas>
      </div>
      <div class="stage">
        <div id="gui"></div>
      </div>
    </div>
    <div class="stage">
      <pre id="debug"></pre>
      <pre id="cell_debug"></pre>
    </div>
  </div>

  <script type="module">
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm";

    const canvas = document.getElementById("grid");
    const statusEl = document.getElementById("status");
    const debugEl = document.getElementById("debug");
    const cellDebugEl = document.getElementById("cell_debug");
    const guiHost = document.getElementById("gui");
    const ctx = canvas.getContext("2d");

    const params = {
      cols: 5,
      rows: 5,
      dotRadius: 4,
      dotColor: "#ffffff",
      padding: 60,
      fillColor: "#e8481e",
      fillSize: 1,
      edgeColor: "#9f9f9f",
      edgeThickness: 6,
      vertexGrabRadius: 14,
      magnetRadius: 16,
      mergeRadius: 12,
    };

    const STORAGE_KEY = "hand-gridtypo1-lilgui";
    const filledSquares = new Set();
    const vertexOffsets = new Map();
    const mergedTo = new Map();
    const cellLogLines = [];
    let lastLayout = null;
    let lastBoundaryVertexKeys = new Set();

    function log(message) {
      const time = new Date().toISOString().slice(11, 19);
      debugEl.textContent = `[${time}] ${message}\n` + debugEl.textContent;
    }

    function logCell(message) {
      const time = new Date().toISOString().slice(11, 19);
      cellLogLines.unshift(`[${time}] ${message}`);
      renderCellDebug();
    }

    function renderCellDebug() {
      const filledList = Array.from(filledSquares.values()).sort();
      const vertexList = Array.from(lastBoundaryVertexKeys.values()).sort();
      const movedList = [];
      for (const [key, offset] of vertexOffsets.entries()) {
        movedList.push(`${key} dx=${offset.dx.toFixed(2)} dy=${offset.dy.toFixed(2)}`);
      }
      movedList.sort();
      const mergedList = [];
      for (const [key, target] of mergedTo.entries()) {
        mergedList.push(`${key} -> ${target}`);
      }
      mergedList.sort();
      const summary = [
        `Filled cells (${filledList.length}): ${filledList.join(" ") || "-"}`,
        `Boundary vertices (${vertexList.length}): ${vertexList.join(" ") || "-"}`,
        `Moved vertices (${movedList.length}): ${movedList.join(" | ") || "-"}`,
        `Merged vertices (${mergedList.length}): ${mergedList.join(" | ") || "-"}`,
      ].join("\n");
      cellDebugEl.textContent = `${summary}\n\n${cellLogLines.join("\n")}`.trim();
    }

    function setStatus(text) {
      statusEl.textContent = text;
      log(text);
    }

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const size = Math.max(1, Math.floor(rect.width * dpr));
      canvas.width = size;
      canvas.height = size;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    function getRootVertex(key) {
      let current = key;
      const seen = new Set();
      while (mergedTo.has(current)) {
        if (seen.has(current)) {
          break;
        }
        seen.add(current);
        current = mergedTo.get(current);
      }
      return current;
    }

    function normalizeVertexKey(key) {
      return getRootVertex(key);
    }

    function buildLayout() {
      resizeCanvas();
      const width = canvas.getBoundingClientRect().width;
      const height = canvas.getBoundingClientRect().width;
      ctx.clearRect(0, 0, width, height);

      const cols = Math.max(1, Math.floor(params.cols));
      const rows = Math.max(1, Math.floor(params.rows));
      const pad = Math.max(0, params.padding);
      const innerW = Math.max(1, width - pad * 2);
      const innerH = Math.max(1, height - pad * 2);

      const cellW = cols === 1 ? innerW : innerW / (cols - 1);
      const cellH = rows === 1 ? innerH : innerH / (rows - 1);
      const baseVerts = Array.from({ length: rows }, () => Array(cols).fill(null));
      const verts = Array.from({ length: rows }, () => Array(cols).fill(null));
      const baseAt = (ix, iy) => {
        const tx = cols === 1 ? 0.5 : ix / (cols - 1);
        const ty = rows === 1 ? 0.5 : iy / (rows - 1);
        return { x: pad + innerW * tx, y: pad + innerH * ty };
      };
      for (let y = 0; y < rows; y += 1) {
        const ty = rows === 1 ? 0.5 : y / (rows - 1);
        const by = pad + innerH * ty;
        for (let x = 0; x < cols; x += 1) {
          const key = `${x},${y}`;
          const rootKey = getRootVertex(key);
          const offset = vertexOffsets.get(rootKey) || { dx: 0, dy: 0 };
          const base = baseAt(x, y);
          baseVerts[y][x] = base;
          const [rx, ry] = rootKey.split(",").map((v) => Number(v));
          const rootBase = Number.isNaN(rx) || Number.isNaN(ry) ? base : baseAt(rx, ry);
          verts[y][x] = { x: rootBase.x + offset.dx, y: rootBase.y + offset.dy };
        }
      }
      lastLayout = { width, height, cols, rows, pad, innerW, innerH, cellW, cellH, baseVerts, verts };
    }

    function drawGrid() {
      buildLayout();
      if (!lastLayout) {
        return;
      }
      const { cols, rows, pad, cellW, cellH, baseVerts, verts } = lastLayout;

      const boundarySegments = [];
      for (const key of filledSquares) {
        const [cx, cy] = key.split(",").map((v) => Number(v));
        if (Number.isNaN(cx) || Number.isNaN(cy)) {
          continue;
        }
        const leftKey = `${cx - 1},${cy}`;
        const rightKey = `${cx + 1},${cy}`;
        const upKey = `${cx},${cy - 1}`;
        const downKey = `${cx},${cy + 1}`;
        if (cx === 0 || !filledSquares.has(leftKey)) {
          boundarySegments.push({ a: `${cx},${cy}`, b: `${cx},${cy + 1}` });
        }
        if (cx === cols - 2 || !filledSquares.has(rightKey)) {
          boundarySegments.push({ a: `${cx + 1},${cy}`, b: `${cx + 1},${cy + 1}` });
        }
        if (cy === 0 || !filledSquares.has(upKey)) {
          boundarySegments.push({ a: `${cx},${cy}`, b: `${cx + 1},${cy}` });
        }
        if (cy === rows - 2 || !filledSquares.has(downKey)) {
          boundarySegments.push({ a: `${cx},${cy + 1}`, b: `${cx + 1},${cy + 1}` });
        }
      }

      ctx.fillStyle = params.fillColor;
      if (params.fillSize >= 0.999 && filledSquares.size > 0) {
        ctx.save();
        ctx.beginPath();
        for (const key of filledSquares) {
          const [cx, cy] = key.split(",").map((v) => Number(v));
          if (Number.isNaN(cx) || Number.isNaN(cy)) {
            continue;
          }
          const v00 = verts[cy]?.[cx];
          const v10 = verts[cy]?.[cx + 1];
          const v11 = verts[cy + 1]?.[cx + 1];
          const v01 = verts[cy + 1]?.[cx];
          if (!v00 || !v10 || !v11 || !v01) {
            continue;
          }
          ctx.moveTo(v00.x, v00.y);
          ctx.lineTo(v10.x, v10.y);
          ctx.lineTo(v11.x, v11.y);
          ctx.lineTo(v01.x, v01.y);
          ctx.closePath();
        }
        ctx.fill();
        ctx.restore();
      } else {
        for (const key of filledSquares) {
          const [cx, cy] = key.split(",").map((v) => Number(v));
          if (Number.isNaN(cx) || Number.isNaN(cy)) {
            continue;
          }
          const v00 = verts[cy]?.[cx];
          const v10 = verts[cy]?.[cx + 1];
          const v11 = verts[cy + 1]?.[cx + 1];
          const v01 = verts[cy + 1]?.[cx];
          const b00 = baseVerts[cy]?.[cx];
          const b10 = baseVerts[cy]?.[cx + 1];
          const b11 = baseVerts[cy + 1]?.[cx + 1];
          const b01 = baseVerts[cy + 1]?.[cx];
          if (!v00 || !v10 || !v11 || !v01 || !b00 || !b10 || !b11 || !b01) {
            continue;
          }
          let p0 = { ...v00 };
          let p1 = { ...v10 };
          let p2 = { ...v11 };
          let p3 = { ...v01 };
          if (params.fillSize < 0.999) {
            const cxm = (p0.x + p1.x + p2.x + p3.x) / 4;
            const cym = (p0.y + p1.y + p2.y + p3.y) / 4;
            p0 = { x: cxm + (p0.x - cxm) * params.fillSize, y: cym + (p0.y - cym) * params.fillSize };
            p1 = { x: cxm + (p1.x - cxm) * params.fillSize, y: cym + (p1.y - cym) * params.fillSize };
            p2 = { x: cxm + (p2.x - cxm) * params.fillSize, y: cym + (p2.y - cym) * params.fillSize };
            p3 = { x: cxm + (p3.x - cxm) * params.fillSize, y: cym + (p3.y - cym) * params.fillSize };
          } else {
            p0 = { x: Math.round(p0.x), y: Math.round(p0.y) };
            p1 = { x: Math.round(p1.x), y: Math.round(p1.y) };
            p2 = { x: Math.round(p2.x), y: Math.round(p2.y) };
            p3 = { x: Math.round(p3.x), y: Math.round(p3.y) };
          }
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(b00.x, b00.y);
          ctx.lineTo(b10.x, b10.y);
          ctx.lineTo(b11.x, b11.y);
          ctx.lineTo(b01.x, b01.y);
          ctx.closePath();
          ctx.clip();

          ctx.beginPath();
          ctx.moveTo(p0.x, p0.y);
          ctx.lineTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.lineTo(p3.x, p3.y);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      }

      const boundaryVertexKeys = new Set();
      ctx.strokeStyle = params.edgeColor;
      ctx.lineWidth = params.edgeThickness;
      ctx.lineCap = "square";
      for (const key of filledSquares) {
        const [cx, cy] = key.split(",").map((v) => Number(v));
        if (Number.isNaN(cx) || Number.isNaN(cy)) {
          continue;
        }
        const v00 = verts[cy]?.[cx];
        const v10 = verts[cy]?.[cx + 1];
        const v11 = verts[cy + 1]?.[cx + 1];
        const v01 = verts[cy + 1]?.[cx];
        if (!v00 || !v10 || !v11 || !v01) {
          continue;
        }
        const leftKey = `${cx - 1},${cy}`;
        const rightKey = `${cx + 1},${cy}`;
        const upKey = `${cx},${cy - 1}`;
        const downKey = `${cx},${cy + 1}`;
        if (cx === 0 || !filledSquares.has(leftKey)) {
          ctx.beginPath();
          ctx.moveTo(v00.x, v00.y);
          ctx.lineTo(v01.x, v01.y);
          ctx.stroke();
          boundaryVertexKeys.add(normalizeVertexKey(`${cx},${cy}`));
          boundaryVertexKeys.add(normalizeVertexKey(`${cx},${cy + 1}`));
        }
        if (cx === cols - 2 || !filledSquares.has(rightKey)) {
          ctx.beginPath();
          ctx.moveTo(v10.x, v10.y);
          ctx.lineTo(v11.x, v11.y);
          ctx.stroke();
          boundaryVertexKeys.add(normalizeVertexKey(`${cx + 1},${cy}`));
          boundaryVertexKeys.add(normalizeVertexKey(`${cx + 1},${cy + 1}`));
        }
        if (cy === 0 || !filledSquares.has(upKey)) {
          ctx.beginPath();
          ctx.moveTo(v00.x, v00.y);
          ctx.lineTo(v10.x, v10.y);
          ctx.stroke();
          boundaryVertexKeys.add(normalizeVertexKey(`${cx},${cy}`));
          boundaryVertexKeys.add(normalizeVertexKey(`${cx + 1},${cy}`));
        }
        if (cy === rows - 2 || !filledSquares.has(downKey)) {
          ctx.beginPath();
          ctx.moveTo(v01.x, v01.y);
          ctx.lineTo(v11.x, v11.y);
          ctx.stroke();
          boundaryVertexKeys.add(normalizeVertexKey(`${cx},${cy + 1}`));
          boundaryVertexKeys.add(normalizeVertexKey(`${cx + 1},${cy + 1}`));
        }
      }

      ctx.fillStyle = params.dotColor;
      for (let y = 0; y < rows; y += 1) {
        for (let x = 0; x < cols; x += 1) {
          const v = baseVerts[y][x];
          if (!v) {
            continue;
          }
          ctx.beginPath();
          ctx.arc(v.x, v.y, params.dotRadius, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      if (filledSquares.size > 0) {
        ctx.fillStyle = params.edgeColor;
        const vertexRadius = Math.max(2, Math.floor(params.edgeThickness));
        const drawnPositions = new Set();
        for (const vKey of boundaryVertexKeys) {
          const [vx, vy] = vKey.split(",").map((v) => Number(v));
          const v = verts[vy]?.[vx];
          if (!v) {
            continue;
          }
          const posKey = `${Math.round(v.x)}|${Math.round(v.y)}`;
          if (drawnPositions.has(posKey)) {
            continue;
          }
          drawnPositions.add(posKey);
          ctx.beginPath();
          ctx.arc(v.x, v.y, vertexRadius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      lastBoundaryVertexKeys = new Set(boundaryVertexKeys);
      if (!draggingVertexKey) {
        renderCellDebug();
      }
    }

    const gui = new GUI({ container: guiHost, title: "Grid" });
    gui.add(params, "cols", 1, 50, 1).name("n(横)").onChange(drawGrid);
    gui.add(params, "rows", 1, 50, 1).name("n(縦)").onChange(drawGrid);
    gui.add(params, "dotRadius", 1, 10, 1).name("dotRadius").onChange(drawGrid);
    gui.addColor(params, "dotColor").name("dotColor").onChange(drawGrid);
    gui.add(params, "padding", 0, 80, 1).name("padding").onChange(drawGrid);
    gui.addColor(params, "fillColor").name("fillColor").onChange(drawGrid);
    gui.add(params, "fillSize", 0.2, 1, 0.05).name("fillSize").onChange(drawGrid);
    gui.addColor(params, "edgeColor").name("edgeColor").onChange(drawGrid);
    gui.add(params, "edgeThickness", 1, 10, 1).name("edgeThickness").onChange(drawGrid);
    gui.add(params, "vertexGrabRadius", 6, 30, 1).name("vertexGrabRadius").onChange(drawGrid);
    gui.add(params, "magnetRadius", 4, 40, 1).name("magnetRadius").onChange(drawGrid);
    gui.add(params, "mergeRadius", 2, 40, 1).name("mergeRadius").onChange(drawGrid);

    const copyText = async (text) => {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        return;
      }
      const textarea = document.createElement("textarea");
      textarea.value = text;
      textarea.style.position = "fixed";
      textarea.style.opacity = "0";
      document.body.appendChild(textarea);
      textarea.focus();
      textarea.select();
      document.execCommand("copy");
      document.body.removeChild(textarea);
    };

    const io = {
      save: () => {
        const data = gui.save();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        setStatus("Preset saved");
      },
      load: () => {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (!saved) {
          setStatus("No preset saved");
          return;
        }
        gui.load(JSON.parse(saved));
        drawGrid();
        setStatus("Preset loaded");
      },
      reset: () => {
        gui.reset();
        drawGrid();
        setStatus("Preset reset");
      },
      copy: async () => {
        const data = gui.save();
        await copyText(JSON.stringify(data, null, 2));
        setStatus("Preset copied");
      },
    };

    gui.add(io, "save").name("save preset");
    gui.add(io, "load").name("load preset");
    gui.add(io, "reset").name("reset");
    gui.add(io, "copy").name("copy preset");

    function cellFromPoint(x, y) {
      const width = canvas.getBoundingClientRect().width;
      const height = canvas.getBoundingClientRect().width;
      const cols = Math.max(1, Math.floor(params.cols));
      const rows = Math.max(1, Math.floor(params.rows));
      const pad = Math.max(0, params.padding);
      const innerW = Math.max(1, width - pad * 2);
      const innerH = Math.max(1, height - pad * 2);
      if (x < pad || y < pad || x > pad + innerW || y > pad + innerH) {
        return null;
      }
      const cellW = cols === 1 ? innerW : innerW / (cols - 1);
      const cellH = rows === 1 ? innerH : innerH / (rows - 1);
      const maxX = Math.max(0, cols - 2);
      const maxY = Math.max(0, rows - 2);
      const cx = Math.min(maxX, Math.max(0, Math.floor((x - pad) / cellW)));
      const cy = Math.min(maxY, Math.max(0, Math.floor((y - pad) / cellH)));
      return { cx, cy };
    }

    function keyFromPoint(x, y) {
      const cell = cellFromPoint(x, y);
      if (!cell) {
        return null;
      }
      return `${cell.cx},${cell.cy}`;
    }

    function setSquareByKey(key, filled) {
      if (!key) {
        return false;
      }
      const has = filledSquares.has(key);
      if (filled) {
        if (!has) {
          filledSquares.add(key);
          logCell(`Cell filled: ${key}`);
          return true;
        }
        return false;
      }
      if (filledSquares.has(key)) {
        filledSquares.delete(key);
        clearCellVertexOffsets(key);
        pruneVertexOffsets();
        logCell(`Cell cleared: ${key}`);
        return true;
      } else {
        filledSquares.add(key);
        logCell(`Cell toggled on: ${key}`);
        return true;
      }
    }

    function clearCellByKey(key) {
      if (!key) {
        return false;
      }
      const hadCell = filledSquares.delete(key);
      clearCellVertexOffsets(key);
      pruneVertexOffsets();
      if (hadCell) {
        logCell(`Cell cleared: ${key}`);
      } else {
        logCell(`Cell vertex cleared: ${key}`);
      }
      return true;
    }

    function clearCellVertexOffsets(cellKey) {
      const [cx, cy] = cellKey.split(",").map((v) => Number(v));
      if (Number.isNaN(cx) || Number.isNaN(cy)) {
        return;
      }
      const keys = [
        `${cx},${cy}`,
        `${cx + 1},${cy}`,
        `${cx},${cy + 1}`,
        `${cx + 1},${cy + 1}`,
      ];
      for (const key of keys) {
        vertexOffsets.delete(key);
        mergedTo.delete(key);
      }
    }

    function pruneVertexOffsets() {
      const active = new Set();
      for (const key of filledSquares) {
        const [cx, cy] = key.split(",").map((v) => Number(v));
        if (Number.isNaN(cx) || Number.isNaN(cy)) {
          continue;
        }
        active.add(`${cx},${cy}`);
        active.add(`${cx + 1},${cy}`);
        active.add(`${cx},${cy + 1}`);
        active.add(`${cx + 1},${cy + 1}`);
      }
      for (const key of vertexOffsets.keys()) {
        if (!active.has(key)) {
          vertexOffsets.delete(key);
        }
      }
      for (const key of mergedTo.keys()) {
        if (!active.has(key)) {
          mergedTo.delete(key);
        }
      }
    }

    function setSquareAt(x, y, filled) {
      const key = keyFromPoint(x, y);
      return setSquareByKey(key, filled);
    }

    function getCellKeysFromPosition(x, y, layout) {
      const { cols, rows, pad, innerW, innerH } = layout;
      if (x < pad || y < pad || x > pad + innerW || y > pad + innerH) {
        return [];
      }
      const cellW = cols === 1 ? innerW : innerW / (cols - 1);
      const cellH = rows === 1 ? innerH : innerH / (rows - 1);
      const maxX = Math.max(0, cols - 2);
      const maxY = Math.max(0, rows - 2);
      const gx = (x - pad) / cellW;
      const gy = (y - pad) / cellH;
      const baseX = Math.min(maxX, Math.max(0, Math.floor(gx)));
      const baseY = Math.min(maxY, Math.max(0, Math.floor(gy)));
      const epsPx = 2;
      const xKeys = new Set([baseX]);
      const yKeys = new Set([baseY]);
      const nearestX = Math.round(gx);
      const nearestY = Math.round(gy);
      if (Math.abs((gx - nearestX) * cellW) <= epsPx) {
        const left = nearestX - 1;
        const right = nearestX;
        if (left >= 0 && left <= maxX) {
          xKeys.add(left);
        }
        if (right >= 0 && right <= maxX) {
          xKeys.add(right);
        }
      }
      if (Math.abs((gy - nearestY) * cellH) <= epsPx) {
        const top = nearestY - 1;
        const bottom = nearestY;
        if (top >= 0 && top <= maxY) {
          yKeys.add(top);
        }
        if (bottom >= 0 && bottom <= maxY) {
          yKeys.add(bottom);
        }
      }
      const keys = [];
      for (const cx of xKeys) {
        for (const cy of yKeys) {
          keys.push(`${cx},${cy}`);
        }
      }
      return keys;
    }

    function getBaseAt(ix, iy, layout) {
      const { cols, rows, pad, innerW, innerH } = layout;
      const tx = cols === 1 ? 0.5 : ix / (cols - 1);
      const ty = rows === 1 ? 0.5 : iy / (rows - 1);
      return { x: pad + innerW * tx, y: pad + innerH * ty };
    }

    function cellHasVertexData(cellKey) {
      if (!cellKey) {
        return false;
      }
      if (!lastLayout) {
        buildLayout();
      }
      if (!lastLayout) {
        return false;
      }
      const layout = lastLayout;
      const rootKeys = new Set();
      for (const key of vertexOffsets.keys()) {
        rootKeys.add(getRootVertex(key));
      }
      for (const target of mergedTo.values()) {
        rootKeys.add(getRootVertex(target));
      }
      for (const rootKey of rootKeys) {
        const [rx, ry] = rootKey.split(",").map((v) => Number(v));
        if (Number.isNaN(rx) || Number.isNaN(ry)) {
          continue;
        }
        const base = getBaseAt(rx, ry, layout);
        const offset = vertexOffsets.get(rootKey) || { dx: 0, dy: 0 };
        const px = base.x + offset.dx;
        const py = base.y + offset.dy;
        const atCells = getCellKeysFromPosition(px, py, layout);
        if (atCells.includes(cellKey)) {
          return true;
        }
      }
      return false;
    }

    function toggleSquareAt(x, y) {
      if (setSquareAt(x, y, null)) {
        drawGrid();
      }
    }

    let isPainting = false;
    let paintValue = true;
    let lastPaintKey = null;
    let draggingVertexKey = null;
    let dragStartOffset = null;
    let dragLastOffset = null;
    let pendingDraw = false;

    function scheduleDraw() {
      if (pendingDraw) {
        return;
      }
      pendingDraw = true;
      requestAnimationFrame(() => {
        pendingDraw = false;
        drawGrid();
      });
    }

    function findNearestVertex(x, y) {
      if (filledSquares.size === 0) {
        return null;
      }
      if (!lastLayout) {
        return null;
      }
      const { cols, rows, verts } = lastLayout;
      const vertexKeys = new Set();
      for (const key of filledSquares) {
        const [cx, cy] = key.split(",").map((v) => Number(v));
        if (Number.isNaN(cx) || Number.isNaN(cy)) {
          continue;
        }
        const leftKey = `${cx - 1},${cy}`;
        const rightKey = `${cx + 1},${cy}`;
        const upKey = `${cx},${cy - 1}`;
        const downKey = `${cx},${cy + 1}`;
        if (cx === 0 || !filledSquares.has(leftKey)) {
          vertexKeys.add(normalizeVertexKey(`${cx},${cy}`));
          vertexKeys.add(normalizeVertexKey(`${cx},${cy + 1}`));
        }
        if (cx === cols - 2 || !filledSquares.has(rightKey)) {
          vertexKeys.add(normalizeVertexKey(`${cx + 1},${cy}`));
          vertexKeys.add(normalizeVertexKey(`${cx + 1},${cy + 1}`));
        }
        if (cy === 0 || !filledSquares.has(upKey)) {
          vertexKeys.add(normalizeVertexKey(`${cx},${cy}`));
          vertexKeys.add(normalizeVertexKey(`${cx + 1},${cy}`));
        }
        if (cy === rows - 2 || !filledSquares.has(downKey)) {
          vertexKeys.add(normalizeVertexKey(`${cx},${cy + 1}`));
          vertexKeys.add(normalizeVertexKey(`${cx + 1},${cy + 1}`));
        }
      }
      let best = null;
      let bestDist = Infinity;
      for (const vKey of vertexKeys) {
        const [vx, vy] = vKey.split(",").map((v) => Number(v));
        const v = verts[vy]?.[vx];
        if (!v) {
          continue;
        }
        const dx = v.x - x;
        const dy = v.y - y;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestDist) {
          bestDist = d2;
          best = { x: vx, y: vy, pos: v, dist: Math.sqrt(d2) };
        }
      }
      if (!best || best.dist > params.vertexGrabRadius) {
        return null;
      }
      const rootKey = getRootVertex(`${best.x},${best.y}`);
      const [rx, ry] = rootKey.split(",").map((v) => Number(v));
      return { x: rx, y: ry, pos: best.pos, dist: best.dist };
    }

    function snapToMagnet(x, y, excludeKey) {
      if (!lastLayout) {
        return { x, y };
      }
      const { cols, rows, baseVerts } = lastLayout;
      let best = null;
      let bestDist = params.magnetRadius;
      for (let vy = 0; vy < rows; vy += 1) {
        for (let vx = 0; vx < cols; vx += 1) {
          const base = baseVerts[vy][vx];
          const dx = base.x - x;
          const dy = base.y - y;
          const dist = Math.hypot(dx, dy);
          if (dist <= bestDist) {
            bestDist = dist;
            best = { x: base.x, y: base.y };
          }
        }
      }
      return best ? best : { x, y };
    }

    function snapToMerge(x, y, excludeKey) {
      if (!lastLayout) {
        return { x, y, key: null, source: null, dist: Infinity };
      }
      const { cols, rows, baseVerts, verts } = lastLayout;
      let best = null;
      let bestDist = params.mergeRadius;
      let bestKey = null;
      let bestSource = null;
      for (let vy = 0; vy < rows; vy += 1) {
        for (let vx = 0; vx < cols; vx += 1) {
          const key = `${vx},${vy}`;
          const base = baseVerts[vy][vx];
          const moved = verts[vy][vx];
          const candidates = key === excludeKey ? [base] : [base, moved];
          for (const v of candidates) {
            const dx = v.x - x;
            const dy = v.y - y;
            const dist = Math.hypot(dx, dy);
            if (dist <= bestDist) {
              bestDist = dist;
              best = { x: v.x, y: v.y };
              bestKey = key;
              bestSource = v === moved ? "moved" : "base";
            }
          }
        }
      }
      return best
        ? { ...best, key: bestKey, source: bestSource, dist: bestDist }
        : { x, y, key: null, source: null, dist: Infinity };
    }

    canvas.addEventListener("contextmenu", (event) => {
      event.preventDefault();
    });

    canvas.addEventListener("pointerdown", (event) => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      if (event.button === 0) {
        const key = keyFromPoint(x, y);
        const nearest = findNearestVertex(x, y);
        if (nearest) {
          draggingVertexKey = `${nearest.x},${nearest.y}`;
          isPainting = false;
          lastPaintKey = null;
          mergedTo.delete(draggingVertexKey);
          dragStartOffset = vertexOffsets.get(draggingVertexKey) || { dx: 0, dy: 0 };
          dragLastOffset = dragStartOffset;
          canvas.setPointerCapture(event.pointerId);
        } else {
          if (!key) {
            return;
          }
          const shouldClear = filledSquares.has(key) || cellHasVertexData(key);
          if (shouldClear) {
            isPainting = true;
            paintValue = false;
            lastPaintKey = key;
            canvas.setPointerCapture(event.pointerId);
            clearCellByKey(key);
            scheduleDraw();
            return;
          }
          isPainting = false;
          paintValue = false;
          lastPaintKey = null;
          draggingVertexKey = null;
          isPainting = true;
          paintValue = true;
          lastPaintKey = key;
          canvas.setPointerCapture(event.pointerId);
          if (setSquareByKey(key, true)) {
            scheduleDraw();
          }
        }
      } else if (event.button === 2) {
        isPainting = true;
        paintValue = true;
        lastPaintKey = null;
        draggingVertexKey = null;
        canvas.setPointerCapture(event.pointerId);
        if (setSquareAt(x, y, paintValue)) {
          scheduleDraw();
        }
      }
    });

    canvas.addEventListener("pointermove", (event) => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      if (draggingVertexKey) {
        if (!lastLayout) {
          return;
        }
        const [vx, vy] = draggingVertexKey.split(",").map((v) => Number(v));
        const base = lastLayout.baseVerts[vy]?.[vx];
        if (!base) {
          return;
        }
        const snapped = snapToMagnet(x, y, draggingVertexKey);
        const offset = { dx: snapped.x - base.x, dy: snapped.y - base.y };
        vertexOffsets.set(draggingVertexKey, offset);
        dragLastOffset = offset;
        scheduleDraw();
        return;
      }
      if (!isPainting) {
        return;
      }
      const key = keyFromPoint(x, y);
      if (!key || key === lastPaintKey) {
        return;
      }
      lastPaintKey = key;
      if (setSquareByKey(key, paintValue)) {
        scheduleDraw();
      }
    });

    canvas.addEventListener("pointerup", (event) => {
      const rect = canvas.getBoundingClientRect();
      const upX = event.clientX - rect.left;
      const upY = event.clientY - rect.top;
      if (isPainting) {
        isPainting = false;
        lastPaintKey = null;
        canvas.releasePointerCapture(event.pointerId);
      }
      if (draggingVertexKey) {
        if (dragStartOffset && dragLastOffset) {
          const dx = dragLastOffset.dx - dragStartOffset.dx;
          const dy = dragLastOffset.dy - dragStartOffset.dy;
          if (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01) {
            logCell(`Vertex moved: ${draggingVertexKey} dx=${dragLastOffset.dx.toFixed(2)} dy=${dragLastOffset.dy.toFixed(2)}`);
          }
        }
        if (lastLayout && dragLastOffset) {
          const [vx, vy] = draggingVertexKey.split(",").map((v) => Number(v));
          const base = lastLayout.baseVerts[vy]?.[vx];
          if (base) {
            const current = { x: base.x + dragLastOffset.dx, y: base.y + dragLastOffset.dy };
            const snapped = snapToMerge(current.x, current.y, draggingVertexKey);
            if (snapped.key && snapped.key !== draggingVertexKey && snapped.source === "moved") {
              const targetRoot = getRootVertex(snapped.key);
              if (targetRoot && targetRoot !== draggingVertexKey) {
                const targetBase = lastLayout.baseVerts[Number(targetRoot.split(",")[1])]?.[Number(targetRoot.split(",")[0])];
                if (targetBase) {
                  mergedTo.set(draggingVertexKey, targetRoot);
                  vertexOffsets.set(targetRoot, { dx: snapped.x - targetBase.x, dy: snapped.y - targetBase.y });
                  vertexOffsets.delete(draggingVertexKey);
                  logCell(`Vertex merged: ${draggingVertexKey} -> ${targetRoot} source=${snapped.source} dist=${snapped.dist.toFixed(2)}`);
                  const upDist = Math.hypot(upX - snapped.x, upY - snapped.y);
                  if (upDist <= params.mergeRadius) {
                    const cellKeys = getCellKeysFromPosition(snapped.x, snapped.y, lastLayout);
                    for (const cellKey of cellKeys) {
                      if (!filledSquares.has(cellKey)) {
                        filledSquares.add(cellKey);
                        logCell(`Cell auto-added: ${cellKey}`);
                      }
                    }
                  }
                }
              } else {
                mergedTo.delete(draggingVertexKey);
                vertexOffsets.set(draggingVertexKey, { dx: snapped.x - base.x, dy: snapped.y - base.y });
              }
            } else {
              mergedTo.delete(draggingVertexKey);
              vertexOffsets.set(draggingVertexKey, { dx: snapped.x - base.x, dy: snapped.y - base.y });
            }
          }
        }
        draggingVertexKey = null;
        dragStartOffset = null;
        dragLastOffset = null;
        canvas.releasePointerCapture(event.pointerId);
        scheduleDraw();
      }
    });

    canvas.addEventListener("pointercancel", () => {
      isPainting = false;
      lastPaintKey = null;
      draggingVertexKey = null;
      dragStartOffset = null;
      dragLastOffset = null;
    });

    window.addEventListener("resize", drawGrid);

    setStatus("Ready");
    drawGrid();
  </script>
</body>
</html>

