<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>hand_gridtypo1</title>
  <style>
    :root {
      color-scheme: light;
    }
    body {
      margin: 0;
      font-family: "IBM Plex Sans", system-ui, sans-serif;
      background: #363636;
      color: #e6e6e6;
    }
    .wrap {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0;
      padding: 0;
    }
    .main {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0;
    }
    .stage {
      background: #363636;
      border: 1px solid #5e5e5e;
      border-radius: 0;
      padding: 12px;
      box-shadow: none;
    }
    .wrap > .stage,
    .wrap > .main {
      border: 1px solid #5e5e5e;
    }
    .wrap > .main {
      border-bottom: none;
    }
    .wrap > .stage {
      border-top: 1px solid #5e5e5e;
    }
    .main > .stage {
      border: none;
    }
    .main > .stage + .stage {
      border-left: 1px solid #5e5e5e;
    }
    canvas {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 0;
      background: #363636;
      border: none;
    }
    .status {
      font-size: 14px;
      opacity: 0.8;
      margin-bottom: 8px;
    }
    .lil-gui {
      --background-color: #363636;
      --text-color: #ffffff;
      --title-background-color: #9f9f9f;
      --title-text-color: #000000;
      --number-color: #e8481e;
      --accent-color: #e8481e;
    }
    pre {
      margin: 0;
      font-size: 12px;
      line-height: 1.4;
      white-space: pre-wrap;
    }
    @media (min-width: 960px) {
      .main {
        grid-template-columns: 1.2fr 0.8fr;
        align-items: stretch;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="main">
      <div class="stage">
        <div class="status" id="status">Grid Editor</div>
        <canvas id="grid"></canvas>
      </div>
      <div class="stage">
        <div id="gui"></div>
      </div>
    </div>
    <div class="stage">
      <pre id="debug"></pre>
      <pre id="cell_debug"></pre>
    </div>
  </div>

  <script type="module">
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm";

    const canvas = document.getElementById("grid");
    const statusEl = document.getElementById("status");
    const debugEl = document.getElementById("debug");
    const cellDebugEl = document.getElementById("cell_debug");
    const guiHost = document.getElementById("gui");
    const ctx = canvas.getContext("2d");

    const params = {
      cols: 5,
      rows: 5,
      dotRadius: 4,
      dotColor: "#ffffff",
      padding: 60,
      fillColor: "#e8481e",
      fillSize: 1,
      edgeColor: "#9f9f9f",
      edgeThickness: 6,
      vertexGrabRadius: 14,
      magnetRadius: 16,
    };

    const STORAGE_KEY = "hand-gridtypo1-lilgui";
    const filledSquares = new Set();
    const vertexOffsets = new Map();
    let lastLayout = null;

    function log(message) {
      const time = new Date().toISOString().slice(11, 19);
      debugEl.textContent = `[${time}] ${message}\n` + debugEl.textContent;
    }

    function logCell(message) {
      const time = new Date().toISOString().slice(11, 19);
      cellDebugEl.textContent = `[${time}] ${message}\n` + cellDebugEl.textContent;
    }

    function setStatus(text) {
      statusEl.textContent = text;
      log(text);
    }

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const size = Math.max(1, Math.floor(rect.width * dpr));
      canvas.width = size;
      canvas.height = size;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    function buildLayout() {
      resizeCanvas();
      const width = canvas.getBoundingClientRect().width;
      const height = canvas.getBoundingClientRect().width;
      ctx.clearRect(0, 0, width, height);

      const cols = Math.max(1, Math.floor(params.cols));
      const rows = Math.max(1, Math.floor(params.rows));
      const pad = Math.max(0, params.padding);
      const innerW = Math.max(1, width - pad * 2);
      const innerH = Math.max(1, height - pad * 2);

      const cellW = cols === 1 ? innerW : innerW / (cols - 1);
      const cellH = rows === 1 ? innerH : innerH / (rows - 1);
      const baseVerts = Array.from({ length: rows }, () => Array(cols).fill(null));
      const verts = Array.from({ length: rows }, () => Array(cols).fill(null));
      for (let y = 0; y < rows; y += 1) {
        const ty = rows === 1 ? 0.5 : y / (rows - 1);
        const by = pad + innerH * ty;
        for (let x = 0; x < cols; x += 1) {
          const tx = cols === 1 ? 0.5 : x / (cols - 1);
          const bx = pad + innerW * tx;
          const key = `${x},${y}`;
          const offset = vertexOffsets.get(key) || { dx: 0, dy: 0 };
          baseVerts[y][x] = { x: bx, y: by };
          verts[y][x] = { x: bx + offset.dx, y: by + offset.dy };
        }
      }
      lastLayout = { width, height, cols, rows, pad, innerW, innerH, cellW, cellH, baseVerts, verts };
    }

    function drawGrid() {
      buildLayout();
      if (!lastLayout) {
        return;
      }
      const { cols, rows, pad, cellW, cellH, baseVerts, verts } = lastLayout;

      const boundarySegments = [];
      for (const key of filledSquares) {
        const [cx, cy] = key.split(",").map((v) => Number(v));
        if (Number.isNaN(cx) || Number.isNaN(cy)) {
          continue;
        }
        const leftKey = `${cx - 1},${cy}`;
        const rightKey = `${cx + 1},${cy}`;
        const upKey = `${cx},${cy - 1}`;
        const downKey = `${cx},${cy + 1}`;
        if (cx === 0 || !filledSquares.has(leftKey)) {
          boundarySegments.push({ a: `${cx},${cy}`, b: `${cx},${cy + 1}` });
        }
        if (cx === cols - 2 || !filledSquares.has(rightKey)) {
          boundarySegments.push({ a: `${cx + 1},${cy}`, b: `${cx + 1},${cy + 1}` });
        }
        if (cy === 0 || !filledSquares.has(upKey)) {
          boundarySegments.push({ a: `${cx},${cy}`, b: `${cx + 1},${cy}` });
        }
        if (cy === rows - 2 || !filledSquares.has(downKey)) {
          boundarySegments.push({ a: `${cx},${cy + 1}`, b: `${cx + 1},${cy + 1}` });
        }
      }

      ctx.fillStyle = params.fillColor;
      if (params.fillSize >= 0.999 && boundarySegments.length > 0) {
        const edgeKey = (a, b) => (a < b ? `${a}|${b}` : `${b}|${a}`);
        const adjacency = new Map();
        for (const seg of boundarySegments) {
          if (!adjacency.has(seg.a)) {
            adjacency.set(seg.a, []);
          }
          if (!adjacency.has(seg.b)) {
            adjacency.set(seg.b, []);
          }
          adjacency.get(seg.a).push(seg.b);
          adjacency.get(seg.b).push(seg.a);
        }

        const loops = [];
        const used = new Set();
        for (const seg of boundarySegments) {
          const startEdge = edgeKey(seg.a, seg.b);
          if (used.has(startEdge)) {
            continue;
          }
          let start = seg.a;
          let current = seg.a;
          let next = seg.b;
          const path = [start];
          while (true) {
            const eKey = edgeKey(current, next);
            if (used.has(eKey)) {
              break;
            }
            used.add(eKey);
            path.push(next);
            const neighbors = adjacency.get(next) || [];
            let candidate = null;
            for (const n of neighbors) {
              const nKey = edgeKey(next, n);
              if (!used.has(nKey)) {
                candidate = n;
                break;
              }
            }
            if (!candidate) {
              if (next === start) {
                loops.push(path);
              }
              break;
            }
            current = next;
            next = candidate;
            if (next === start) {
              path.push(start);
              loops.push(path);
              break;
            }
          }
        }

        if (loops.length > 0) {
          ctx.save();
          ctx.beginPath();
          for (const loop of loops) {
            let started = false;
            for (const vKey of loop) {
              const [vx, vy] = vKey.split(",").map((v) => Number(v));
              const v = verts[vy]?.[vx];
              if (!v) {
                continue;
              }
              if (!started) {
                ctx.moveTo(v.x, v.y);
                started = true;
              } else {
                ctx.lineTo(v.x, v.y);
              }
            }
            if (started) {
              ctx.closePath();
            }
          }
          ctx.fill("evenodd");
          ctx.restore();
        }
      } else {
        for (const key of filledSquares) {
          const [cx, cy] = key.split(",").map((v) => Number(v));
          if (Number.isNaN(cx) || Number.isNaN(cy)) {
            continue;
          }
          const v00 = verts[cy]?.[cx];
          const v10 = verts[cy]?.[cx + 1];
          const v11 = verts[cy + 1]?.[cx + 1];
          const v01 = verts[cy + 1]?.[cx];
          const b00 = baseVerts[cy]?.[cx];
          const b10 = baseVerts[cy]?.[cx + 1];
          const b11 = baseVerts[cy + 1]?.[cx + 1];
          const b01 = baseVerts[cy + 1]?.[cx];
          if (!v00 || !v10 || !v11 || !v01 || !b00 || !b10 || !b11 || !b01) {
            continue;
          }
          let p0 = { ...v00 };
          let p1 = { ...v10 };
          let p2 = { ...v11 };
          let p3 = { ...v01 };
          if (params.fillSize < 0.999) {
            const cxm = (p0.x + p1.x + p2.x + p3.x) / 4;
            const cym = (p0.y + p1.y + p2.y + p3.y) / 4;
            p0 = { x: cxm + (p0.x - cxm) * params.fillSize, y: cym + (p0.y - cym) * params.fillSize };
            p1 = { x: cxm + (p1.x - cxm) * params.fillSize, y: cym + (p1.y - cym) * params.fillSize };
            p2 = { x: cxm + (p2.x - cxm) * params.fillSize, y: cym + (p2.y - cym) * params.fillSize };
            p3 = { x: cxm + (p3.x - cxm) * params.fillSize, y: cym + (p3.y - cym) * params.fillSize };
          } else {
            p0 = { x: Math.round(p0.x), y: Math.round(p0.y) };
            p1 = { x: Math.round(p1.x), y: Math.round(p1.y) };
            p2 = { x: Math.round(p2.x), y: Math.round(p2.y) };
            p3 = { x: Math.round(p3.x), y: Math.round(p3.y) };
          }
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(b00.x, b00.y);
          ctx.lineTo(b10.x, b10.y);
          ctx.lineTo(b11.x, b11.y);
          ctx.lineTo(b01.x, b01.y);
          ctx.closePath();
          ctx.clip();

          ctx.beginPath();
          ctx.moveTo(p0.x, p0.y);
          ctx.lineTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.lineTo(p3.x, p3.y);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      }

      const boundaryVertexKeys = new Set();
      ctx.strokeStyle = params.edgeColor;
      ctx.lineWidth = params.edgeThickness;
      ctx.lineCap = "square";
      for (const key of filledSquares) {
        const [cx, cy] = key.split(",").map((v) => Number(v));
        if (Number.isNaN(cx) || Number.isNaN(cy)) {
          continue;
        }
        const v00 = verts[cy]?.[cx];
        const v10 = verts[cy]?.[cx + 1];
        const v11 = verts[cy + 1]?.[cx + 1];
        const v01 = verts[cy + 1]?.[cx];
        if (!v00 || !v10 || !v11 || !v01) {
          continue;
        }
        const leftKey = `${cx - 1},${cy}`;
        const rightKey = `${cx + 1},${cy}`;
        const upKey = `${cx},${cy - 1}`;
        const downKey = `${cx},${cy + 1}`;
        if (cx === 0 || !filledSquares.has(leftKey)) {
          ctx.beginPath();
          ctx.moveTo(v00.x, v00.y);
          ctx.lineTo(v01.x, v01.y);
          ctx.stroke();
          boundaryVertexKeys.add(`${cx},${cy}`);
          boundaryVertexKeys.add(`${cx},${cy + 1}`);
        }
        if (cx === cols - 2 || !filledSquares.has(rightKey)) {
          ctx.beginPath();
          ctx.moveTo(v10.x, v10.y);
          ctx.lineTo(v11.x, v11.y);
          ctx.stroke();
          boundaryVertexKeys.add(`${cx + 1},${cy}`);
          boundaryVertexKeys.add(`${cx + 1},${cy + 1}`);
        }
        if (cy === 0 || !filledSquares.has(upKey)) {
          ctx.beginPath();
          ctx.moveTo(v00.x, v00.y);
          ctx.lineTo(v10.x, v10.y);
          ctx.stroke();
          boundaryVertexKeys.add(`${cx},${cy}`);
          boundaryVertexKeys.add(`${cx + 1},${cy}`);
        }
        if (cy === rows - 2 || !filledSquares.has(downKey)) {
          ctx.beginPath();
          ctx.moveTo(v01.x, v01.y);
          ctx.lineTo(v11.x, v11.y);
          ctx.stroke();
          boundaryVertexKeys.add(`${cx},${cy + 1}`);
          boundaryVertexKeys.add(`${cx + 1},${cy + 1}`);
        }
      }

      ctx.fillStyle = params.dotColor;
      for (let y = 0; y < rows; y += 1) {
        for (let x = 0; x < cols; x += 1) {
          const v = baseVerts[y][x];
          if (!v) {
            continue;
          }
          ctx.beginPath();
          ctx.arc(v.x, v.y, params.dotRadius, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      if (filledSquares.size > 0) {
        ctx.fillStyle = params.edgeColor;
        const vertexRadius = Math.max(2, Math.floor(params.edgeThickness));
        for (const vKey of boundaryVertexKeys) {
          const [vx, vy] = vKey.split(",").map((v) => Number(v));
          const v = verts[vy]?.[vx];
          if (!v) {
            continue;
          }
          ctx.beginPath();
          ctx.arc(v.x, v.y, vertexRadius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    const gui = new GUI({ container: guiHost, title: "Grid" });
    gui.add(params, "cols", 1, 50, 1).name("n(横)").onChange(drawGrid);
    gui.add(params, "rows", 1, 50, 1).name("n(縦)").onChange(drawGrid);
    gui.add(params, "dotRadius", 1, 10, 1).name("dotRadius").onChange(drawGrid);
    gui.addColor(params, "dotColor").name("dotColor").onChange(drawGrid);
    gui.add(params, "padding", 0, 80, 1).name("padding").onChange(drawGrid);
    gui.addColor(params, "fillColor").name("fillColor").onChange(drawGrid);
    gui.add(params, "fillSize", 0.2, 1, 0.05).name("fillSize").onChange(drawGrid);
    gui.addColor(params, "edgeColor").name("edgeColor").onChange(drawGrid);
    gui.add(params, "edgeThickness", 1, 10, 1).name("edgeThickness").onChange(drawGrid);
    gui.add(params, "vertexGrabRadius", 6, 30, 1).name("vertexGrabRadius").onChange(drawGrid);
    gui.add(params, "magnetRadius", 4, 40, 1).name("magnetRadius").onChange(drawGrid);

    const copyText = async (text) => {
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        return;
      }
      const textarea = document.createElement("textarea");
      textarea.value = text;
      textarea.style.position = "fixed";
      textarea.style.opacity = "0";
      document.body.appendChild(textarea);
      textarea.focus();
      textarea.select();
      document.execCommand("copy");
      document.body.removeChild(textarea);
    };

    const io = {
      save: () => {
        const data = gui.save();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
        setStatus("Preset saved");
      },
      load: () => {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (!saved) {
          setStatus("No preset saved");
          return;
        }
        gui.load(JSON.parse(saved));
        drawGrid();
        setStatus("Preset loaded");
      },
      reset: () => {
        gui.reset();
        drawGrid();
        setStatus("Preset reset");
      },
      copy: async () => {
        const data = gui.save();
        await copyText(JSON.stringify(data, null, 2));
        setStatus("Preset copied");
      },
    };

    gui.add(io, "save").name("save preset");
    gui.add(io, "load").name("load preset");
    gui.add(io, "reset").name("reset");
    gui.add(io, "copy").name("copy preset");

    function cellFromPoint(x, y) {
      const width = canvas.getBoundingClientRect().width;
      const height = canvas.getBoundingClientRect().width;
      const cols = Math.max(1, Math.floor(params.cols));
      const rows = Math.max(1, Math.floor(params.rows));
      const pad = Math.max(0, params.padding);
      const innerW = Math.max(1, width - pad * 2);
      const innerH = Math.max(1, height - pad * 2);
      if (x < pad || y < pad || x > pad + innerW || y > pad + innerH) {
        return null;
      }
      const cellW = cols === 1 ? innerW : innerW / (cols - 1);
      const cellH = rows === 1 ? innerH : innerH / (rows - 1);
      const maxX = Math.max(0, cols - 2);
      const maxY = Math.max(0, rows - 2);
      const cx = Math.min(maxX, Math.max(0, Math.floor((x - pad) / cellW)));
      const cy = Math.min(maxY, Math.max(0, Math.floor((y - pad) / cellH)));
      return { cx, cy };
    }

    function keyFromPoint(x, y) {
      const cell = cellFromPoint(x, y);
      if (!cell) {
        return null;
      }
      return `${cell.cx},${cell.cy}`;
    }

    function setSquareByKey(key, filled) {
      if (!key) {
        return false;
      }
      const has = filledSquares.has(key);
      if (filled) {
        if (!has) {
          filledSquares.add(key);
          logCell(`Cell filled: ${key}`);
          return true;
        }
        return false;
      }
      if (filledSquares.has(key)) {
        filledSquares.delete(key);
        clearCellVertexOffsets(key);
        pruneVertexOffsets();
        logCell(`Cell cleared: ${key}`);
        return true;
      } else {
        filledSquares.add(key);
        logCell(`Cell toggled on: ${key}`);
        return true;
      }
    }

    function clearCellVertexOffsets(cellKey) {
      const [cx, cy] = cellKey.split(",").map((v) => Number(v));
      if (Number.isNaN(cx) || Number.isNaN(cy)) {
        return;
      }
      vertexOffsets.delete(`${cx},${cy}`);
      vertexOffsets.delete(`${cx + 1},${cy}`);
      vertexOffsets.delete(`${cx},${cy + 1}`);
      vertexOffsets.delete(`${cx + 1},${cy + 1}`);
    }

    function pruneVertexOffsets() {
      const active = new Set();
      for (const key of filledSquares) {
        const [cx, cy] = key.split(",").map((v) => Number(v));
        if (Number.isNaN(cx) || Number.isNaN(cy)) {
          continue;
        }
        active.add(`${cx},${cy}`);
        active.add(`${cx + 1},${cy}`);
        active.add(`${cx},${cy + 1}`);
        active.add(`${cx + 1},${cy + 1}`);
      }
      for (const key of vertexOffsets.keys()) {
        if (!active.has(key)) {
          vertexOffsets.delete(key);
        }
      }
    }

    function setSquareAt(x, y, filled) {
      const key = keyFromPoint(x, y);
      return setSquareByKey(key, filled);
    }

    function toggleSquareAt(x, y) {
      if (setSquareAt(x, y, null)) {
        drawGrid();
      }
    }

    let isPainting = false;
    let paintValue = true;
    let lastPaintKey = null;
    let draggingVertexKey = null;
    let dragStartOffset = null;
    let dragLastOffset = null;
    let pendingDraw = false;

    function scheduleDraw() {
      if (pendingDraw) {
        return;
      }
      pendingDraw = true;
      requestAnimationFrame(() => {
        pendingDraw = false;
        drawGrid();
      });
    }

    function findNearestVertex(x, y) {
      if (filledSquares.size === 0) {
        return null;
      }
      if (!lastLayout) {
        return null;
      }
      const { cols, rows, verts } = lastLayout;
      const vertexKeys = new Set();
      for (const key of filledSquares) {
        const [cx, cy] = key.split(",").map((v) => Number(v));
        if (Number.isNaN(cx) || Number.isNaN(cy)) {
          continue;
        }
        const leftKey = `${cx - 1},${cy}`;
        const rightKey = `${cx + 1},${cy}`;
        const upKey = `${cx},${cy - 1}`;
        const downKey = `${cx},${cy + 1}`;
        if (cx === 0 || !filledSquares.has(leftKey)) {
          vertexKeys.add(`${cx},${cy}`);
          vertexKeys.add(`${cx},${cy + 1}`);
        }
        if (cx === cols - 2 || !filledSquares.has(rightKey)) {
          vertexKeys.add(`${cx + 1},${cy}`);
          vertexKeys.add(`${cx + 1},${cy + 1}`);
        }
        if (cy === 0 || !filledSquares.has(upKey)) {
          vertexKeys.add(`${cx},${cy}`);
          vertexKeys.add(`${cx + 1},${cy}`);
        }
        if (cy === rows - 2 || !filledSquares.has(downKey)) {
          vertexKeys.add(`${cx},${cy + 1}`);
          vertexKeys.add(`${cx + 1},${cy + 1}`);
        }
      }
      let best = null;
      let bestDist = Infinity;
      for (const vKey of vertexKeys) {
        const [vx, vy] = vKey.split(",").map((v) => Number(v));
        const v = verts[vy]?.[vx];
        if (!v) {
          continue;
        }
        const dx = v.x - x;
        const dy = v.y - y;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestDist) {
          bestDist = d2;
          best = { x: vx, y: vy, pos: v, dist: Math.sqrt(d2) };
        }
      }
      if (!best || best.dist > params.vertexGrabRadius) {
        return null;
      }
      return best;
    }

    function snapToMagnet(x, y, excludeKey) {
      if (!lastLayout) {
        return { x, y };
      }
      const { cols, rows, verts, baseVerts } = lastLayout;
      let best = null;
      let bestDist = params.magnetRadius;
      for (let vy = 0; vy < rows; vy += 1) {
        for (let vx = 0; vx < cols; vx += 1) {
          const key = `${vx},${vy}`;
          const base = baseVerts[vy][vx];
          const moved = verts[vy][vx];
          const candidates = key === excludeKey ? [base] : [base, moved];
          for (const v of candidates) {
            const dx = v.x - x;
            const dy = v.y - y;
            const dist = Math.hypot(dx, dy);
            if (dist <= bestDist) {
              bestDist = dist;
              best = { x: v.x, y: v.y };
            }
          }
        }
      }
      return best ? best : { x, y };
    }

    canvas.addEventListener("contextmenu", (event) => {
      event.preventDefault();
    });

    canvas.addEventListener("pointerdown", (event) => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      if (event.button === 0) {
        const key = keyFromPoint(x, y);
        const nearest = findNearestVertex(x, y);
        if (nearest) {
          draggingVertexKey = `${nearest.x},${nearest.y}`;
          isPainting = false;
          lastPaintKey = null;
          dragStartOffset = vertexOffsets.get(draggingVertexKey) || { dx: 0, dy: 0 };
          dragLastOffset = dragStartOffset;
          canvas.setPointerCapture(event.pointerId);
        } else {
          if (!key) {
            return;
          }
          isPainting = true;
          paintValue = false;
          lastPaintKey = key;
          draggingVertexKey = null;
          canvas.setPointerCapture(event.pointerId);
          if (setSquareByKey(key, paintValue)) {
            scheduleDraw();
          }
        }
      } else if (event.button === 2) {
        isPainting = true;
        paintValue = true;
        lastPaintKey = null;
        draggingVertexKey = null;
        canvas.setPointerCapture(event.pointerId);
        if (setSquareAt(x, y, paintValue)) {
          scheduleDraw();
        }
      }
    });

    canvas.addEventListener("pointermove", (event) => {
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      if (draggingVertexKey) {
        if (!lastLayout) {
          return;
        }
        const [vx, vy] = draggingVertexKey.split(",").map((v) => Number(v));
        const base = lastLayout.baseVerts[vy]?.[vx];
        if (!base) {
          return;
        }
        const snapped = snapToMagnet(x, y, draggingVertexKey);
        const offset = { dx: snapped.x - base.x, dy: snapped.y - base.y };
        vertexOffsets.set(draggingVertexKey, offset);
        dragLastOffset = offset;
        scheduleDraw();
        return;
      }
      if (!isPainting) {
        return;
      }
      const key = keyFromPoint(x, y);
      if (!key || key === lastPaintKey) {
        return;
      }
      lastPaintKey = key;
      if (setSquareByKey(key, paintValue)) {
        scheduleDraw();
      }
    });

    canvas.addEventListener("pointerup", (event) => {
      if (isPainting) {
        isPainting = false;
        lastPaintKey = null;
        canvas.releasePointerCapture(event.pointerId);
      }
      if (draggingVertexKey) {
        if (dragStartOffset && dragLastOffset) {
          const dx = dragLastOffset.dx - dragStartOffset.dx;
          const dy = dragLastOffset.dy - dragStartOffset.dy;
          if (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01) {
            logCell(`Vertex moved: ${draggingVertexKey} dx=${dragLastOffset.dx.toFixed(2)} dy=${dragLastOffset.dy.toFixed(2)}`);
          }
        }
        draggingVertexKey = null;
        dragStartOffset = null;
        dragLastOffset = null;
        canvas.releasePointerCapture(event.pointerId);
      }
    });

    canvas.addEventListener("pointercancel", () => {
      isPainting = false;
      lastPaintKey = null;
      draggingVertexKey = null;
      dragStartOffset = null;
      dragLastOffset = null;
    });

    window.addEventListener("resize", drawGrid);

    setStatus("Ready");
    drawGrid();
  </script>
</body>
</html>

